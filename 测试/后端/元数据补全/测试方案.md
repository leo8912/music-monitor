# 元数据补全优化测试方案

## 测试目标
验证移除冷却期和优化搜索策略后的效果：
1. 元数据补全成功率显著提升
2. 系统资源使用合理
3. 不触发API频率限制
4. 用户体验明显改善

## 测试环境准备

### 1. 测试数据准备
```python
# 测试用例设计
TEST_CASES = [
    {
        'name': '标准歌曲',
        'title': '稻香',
        'artist': '周杰伦',
        'expected_outcome': '高成功率'
    },
    {
        'name': '带标点符号',
        'title': '告白气球(Live)',
        'artist': '周杰伦 feat. 五月天',
        'expected_outcome': '中等成功率'
    },
    {
        'name': '英文歌曲',
        'title': 'Shape of You',
        'artist': 'Ed Sheeran',
        'expected_outcome': '高成功率'
    },
    {
        'name': '复杂格式',
        'title': '青花瓷【经典版】',
        'artist': '周杰伦/Jay Chou',
        'expected_outcome': '中等成功率'
    },
    {
        'name': '罕见歌曲',
        'title': '一些很特别的歌名',
        'artist': '不太知名的艺人',
        'expected_outcome': '低成功率'
    }
]
```

### 2. 测试基础设施
```python
# 测试目录结构
测试/后端/元数据补全/
├── test_metadata_healing.py          # 核心功能测试
├── test_search_strategies.py         # 搜索策略测试
├── test_retry_mechanisms.py          # 重试机制测试
├── test_performance_impact.py        # 性能影响测试
├── test_api_compliance.py            # API合规性测试
└── 测试结果/                         # 测试报告和日志
    ├── 20260210_metadata_test_report.md
    ├── performance_metrics.json
    └── error_analysis.log
```

## 测试用例设计

### 1. 功能测试
```python
import pytest
import asyncio
from unittest.mock import Mock, patch
from app.services.metadata_healer import MetadataHealer
from app.services.metadata_service import MetadataService

class TestMetadataHealingWithoutCooldown:
    """测试移除冷却期后的元数据补全功能"""
    
    @pytest.fixture
    def healer(self):
        return MetadataHealer()
    
    @pytest.mark.asyncio
    async def test_immediate_retry_after_failure(self, healer):
        """测试失败后立即重试的能力"""
        # 模拟一首之前失败的歌曲
        mock_song = Mock()
        mock_song.last_enrich_at = None  # 没有上次执行时间
        
        # 应该允许立即重试（无冷却期限制）
        assert not healer._should_skip_enrichment(mock_song)
        
    @pytest.mark.asyncio
    async def test_multiple_concurrent_attempts(self, healer):
        """测试并发处理能力"""
        songs = [Mock() for _ in range(10)]
        for song in songs:
            song.last_enrich_at = None
            
        # 所有歌曲都应该能够同时处理
        results = await asyncio.gather(*[
            healer.heal_song(song.id) for song in songs
        ], return_exceptions=True)
        
        # 验证没有因为冷却期而拒绝处理
        assert not any(isinstance(r, Exception) and "cooldown" in str(r).lower() 
                      for r in results)

class TestProgressiveSearchStrategies:
    """测试渐进式搜索策略"""
    
    @pytest.mark.asyncio
    async def test_keyword_preprocessing(self):
        """测试关键词预处理功能"""
        test_cases = [
            ("稻香(Live)", "周杰伦 feat. 五月天", "稻香 周杰伦 五月天"),
            ("Shape of You", "Ed Sheeran", "Shape of You Ed Sheeran"),
            ("青花瓷【经典版】", "周杰伦", "青花瓷 周杰伦")
        ]
        
        for title, artist, expected in test_cases:
            processed_title, processed_artist = preprocess_search_keywords(title, artist)
            result = f"{processed_title} {processed_artist}".strip()
            assert expected in result or result in expected
    
    @pytest.mark.asyncio
    async def test_multi_strategy_search(self, mocker):
        """测试多策略搜索机制"""
        # 模拟不同的搜索策略
        mock_strategies = [
            Mock(return_value=Mock(success=False)),  # 策略1失败
            Mock(return_value=Mock(success=False)),  # 策略2失败
            Mock(return_value=Mock(success=True)),   # 策略3成功
        ]
        
        healer = MetadataHealer()
        healer._exact_search = mock_strategies[0]
        healer._optimized_search = mock_strategies[1]
        healer._title_only_search = mock_strategies[2]
        
        result = await healer.progressive_metadata_search("测试歌曲", "测试艺人")
        
        # 验证找到了结果
        assert result.success
        # 验证尝试了多个策略
        assert mock_strategies[0].called
        assert mock_strategies[1].called
        assert mock_strategies[2].called
```

### 2. 性能测试
```python
import time
import psutil
import asyncio
from statistics import mean

class TestPerformanceImpact:
    """性能影响测试"""
    
    def test_resource_usage_during_healing(self):
        """测试元数据补全过程中的资源使用"""
        process = psutil.Process()
        initial_memory = process.memory_info().rss
        initial_cpu = process.cpu_percent()
        
        # 执行批量元数据补全
        start_time = time.time()
        asyncio.run(self._batch_heal_test())
        end_time = time.time()
        
        # 测量资源使用
        final_memory = process.memory_info().rss
        final_cpu = process.cpu_percent()
        
        # 验证资源使用在合理范围内
        memory_increase = (final_memory - initial_memory) / 1024 / 1024  # MB
        processing_time = end_time - start_time
        
        print(f"内存增加: {memory_increase:.2f}MB")
        print(f"处理时间: {processing_time:.2f}秒")
        print(f"CPU使用率: {final_cpu:.1f}%")
        
        # 断言：内存增加不超过100MB，处理时间合理
        assert memory_increase < 100
        assert processing_time < 60  # 60秒内处理完一批
    
    async def _batch_heal_test(self):
        """批量处理测试"""
        healer = MetadataHealer()
        test_songs = [Mock(id=f"test_{i}") for i in range(20)]
        
        tasks = [healer.heal_song(song.id) for song in test_songs]
        await asyncio.gather(*tasks, return_exceptions=True)
```

### 3. 集成测试
```python
class TestIntegrationWithRealAPIs:
    """与真实API的集成测试"""
    
    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_netease_api_integration(self):
        """测试网易云API集成"""
        service = MetadataService()
        
        # 测试真实的歌曲搜索
        result = await service.get_best_match_metadata("稻香", "周杰伦")
        
        # 验证返回了有效的元数据
        assert result is not None
        # 至少应该返回部分信息
        assert result.title or result.artist or result.album
        
    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_qqmusic_api_integration(self):
        """测试QQ音乐API集成"""
        service = MetadataService()
        
        # 测试真实的歌曲搜索
        result = await service.fetch_metadata("Shape of You", "Ed Sheeran")
        
        # 验证返回了有效的元数据
        assert result.success
        assert result.cover_url or result.lyrics or result.album
```

## 测试执行计划

### 第一阶段：单元测试（1-2天）
- [ ] 核心功能测试（移除冷却期逻辑）
- [ ] 搜索策略测试（关键词处理、多轮搜索）
- [ ] 重试机制测试（错误分类、差异化处理）

### 第二阶段：集成测试（2-3天）
- [ ] 与网易云API的真实集成测试
- [ ] 与QQ音乐API的真实集成测试
- [ ] 数据库操作集成测试

### 第三阶段：性能测试（1-2天）
- [ ] 资源使用监控测试
- [ ] 并发处理能力测试
- [ ] 压力测试

### 第四阶段：验收测试（2-3天）
- [ ] 端到端功能验证
- [ ] 用户体验测试
- [ ] 生产环境模拟测试

## 成功标准

### 功能指标
- [ ] 元数据补全成功率 ≥ 85%（原基础上提升30%+）
- [ ] 失败后重试间隔 ≤ 5秒
- [ ] 支持并发处理 ≥ 10首歌曲同时补全

### 性能指标
- [ ] 单首歌曲补全平均时间 ≤ 3秒
- [ ] 内存使用增加 ≤ 50MB（处理20首歌曲）
- [ ] CPU使用率峰值 ≤ 70%

### 稳定性指标
- [ ] 连续运行24小时无崩溃
- [ ] 不触发API频率限制
- [ ] 错误恢复时间 ≤ 30秒

## 监控和报告

### 实时监控指标
```python
MONITORING_METRICS = {
    'success_rate': '元数据补全成功率',
    'average_processing_time': '平均处理时间',
    'concurrent_processes': '并发处理数',
    'api_response_time': 'API响应时间',
    'error_types_distribution': '错误类型分布'
}
```

### 测试报告模板
```markdown
# 元数据补全优化测试报告

## 测试概况
- 测试时间: 2026-02-10
- 测试版本: v1.2.0
- 测试环境: Windows 10, Python 3.11

## 核心指标
| 指标 | 优化前 | 优化后 | 改善幅度 |
|------|--------|--------|----------|
| 成功率 | 52% | 87% | +35% |
| 平均处理时间 | 4.2秒 | 2.8秒 | -33% |
| 重试间隔 | 24小时 | 立即 | ∞ |

## 详细分析
[具体测试结果和分析]

## 结论
[测试结论和建议]
```

通过这套完整的测试方案，我们可以科学地验证优化效果，确保改动既提升了成功率又保持了系统稳定性。