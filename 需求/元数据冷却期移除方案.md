# 元数据补全冷却期移除方案

## 问题确认
根据rules.md明确规定：
- 元数据补全使用网易云(pyncm)和QQ音乐(qqmusic-api)接口
- 这些接口没有严格的频率限制
- 真正需要冷却的是GDStudio下载接口(5分钟50次限制)

## 修复要点

### 1. 移除元数据冷却期检查
```python
# BEFORE (错误的实现)
def _in_cooldown(self, song: Song) -> bool:
    """检查是否在冷却期 (24h)"""  # ← 这里应用错了地方
    if not song.last_enrich_at:
        return False
    delta = datetime.now() - song.last_enrich_at
    return delta.total_seconds() < 86400  # 24小时

# AFTER (正确的实现)
def _should_skip_enrichment(self, song: Song) -> bool:
    """元数据补全无需冷却期检查"""
    # 元数据获取使用网易云和QQ音乐接口，没有频率限制
    # 直接返回False，允许随时执行
    return False
```

### 2. 保留必要的重试机制
```python
# 保留合理的重试，但去掉冷却期限制
@async_retry(max_retries=5, backoff_factor=2)  # 增加重试次数
async def _fetch_metadata_with_retry(self, title: str, artist: str):
    """带重试的元数据获取"""
    return await self.metadata_service.get_best_match_metadata(title, artist)
```

### 3. 区分操作类型
```python
class OperationType(Enum):
    METADATA_FETCH = "metadata_fetch"  # 元数据获取 - 无需冷却
    AUDIO_DOWNLOAD = "audio_download"   # 音频下载 - 需要冷却
    SYSTEM_MAINTENANCE = "maintenance"  # 系统维护 - 需要冷却

def get_operation_cooldown(operation_type: OperationType) -> int:
    """根据不同操作类型返回合适的冷却时间"""
    cooldown_map = {
        OperationType.METADATA_FETCH: 0,      # 无冷却
        OperationType.AUDIO_DOWNLOAD: 300,    # 5分钟（GDStudio限制）
        OperationType.SYSTEM_MAINTENANCE: 3600 # 1小时
    }
    return cooldown_map.get(operation_type, 0)
```

## 实施步骤

### 第一阶段：立即修复（1-2天）
1. 移除metadata_healer.py中的冷却期检查逻辑
2. 增加元数据获取的重试次数（3→5次）
3. 优化搜索策略，提高首次成功率

### 第二阶段：验证测试（3-5天）
1. 对比修复前后的元数据补全成功率
2. 监控系统资源使用情况
3. 验证不会触发API频率限制

### 第三阶段：优化完善（1-2周）
1. 实施渐进式搜索策略
2. 增加详细的失败原因日志
3. 建立成功率监控机制

## 预期效果

✅ **提高成功率**：消除不必要的冷却期限制
✅ **加快处理速度**：失败后可立即重试
✅ **改善用户体验**：减少用户手动干预需求
✅ **保持系统稳定**：元数据操作本身资源消耗很小

## 风险控制

🔴 **监控要点**：
- 网易云和QQ音乐API的响应时间和错误率
- 系统CPU和内存使用情况
- 数据库连接和查询性能

🟢 **安全措施**：
- 保留合理的重试机制和超时设置
- 实施渐进式搜索避免过度请求
- 建立告警机制及时发现问题