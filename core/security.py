
import hmac
import hashlib
import time
import logging
from typing import Optional
from core.config import config, ensure_security_config

logger = logging.getLogger(__name__)

# Cache secret key in memory
_SECRET_KEY = None

def get_secret_key():
    global _SECRET_KEY
    if _SECRET_KEY:
        return _SECRET_KEY
    
    # Try to get from config
    s = config.get('global', {}).get('secret_key')
    
    # If not in loaded config, it might be generated by ensure_security_config
    if not s:
        # This call reads file if needed
        s, _ = ensure_security_config()
        
    _SECRET_KEY = s
    return _SECRET_KEY

def generate_signed_url_params(song_id: str, ttl_seconds: int = 259200) -> dict:
    """
    Generate sign and expires params for a given song_id.
    Default TTL: 72 hours (3 days).
    """
    secret = get_secret_key()
    expires = int(time.time()) + ttl_seconds
    
    # Data to sign: "song_id|expires"
    data = f"{song_id}|{expires}"
    
    signature = hmac.new(
        key=secret.encode('utf-8'),
        msg=data.encode('utf-8'),
        digestmod=hashlib.sha256
    ).hexdigest()
    
    # Return as dict for easy url construction
    return {
        "id": song_id,
        "sign": signature,
        "expires": str(expires)
    }

def verify_signature(song_id: str, signature: str, expires: str) -> bool:
    """Verify if the signature is valid and not expired."""
    try:
        # 1. Check Expiration
        exp_ts = int(expires)
        if time.time() > exp_ts:
            logger.warning(f"Signature expired for {song_id}")
            return False
            
        # 2. Re-calculate Signature
        secret = get_secret_key()
        data = f"{song_id}|{expires}"
        
        expected_sign = hmac.new(
            key=secret.encode('utf-8'),
            msg=data.encode('utf-8'),
            digestmod=hashlib.sha256
        ).hexdigest()
        
        # 3. Compare (Constant time comparison)
        if hmac.compare_digest(expected_sign, signature):
            return True
            
        logger.warning(f"Signature mismatch for {song_id}")
        return False
        
    except Exception as e:
        logger.error(f"Signature verification error: {e}")
        return False
